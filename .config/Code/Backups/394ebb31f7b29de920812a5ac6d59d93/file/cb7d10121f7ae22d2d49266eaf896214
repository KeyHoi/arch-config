file:///home/keyhoi/WS1718/IT-Security/Notes/chapter_5.txt
5 Zugriffs- und Informationsflusskontrolle 
    - Discretionary Access Control(DAC): benutzerbestimmt (Role Based Access Control; RBAC)
    - Mandatory Access Control(MAC): systembestimmt 
    - Usage Control(ähnlich wie DRM)

5.1 Modelle 
    - unternehmerische Anforderungen
        > Seperation of Duty: Trennung von Aufgaben => Interessenkonflikt vermeiden
        > Vier Augen Prinzip: kritische Entscheidungen nicht nur von einer Person 
        > Klassifikation der Daten/Informationen
    - Zugriffsmatrix-Modell
        > Menge von Objekten O_t(Datei, Port, ...); Menge von Subjekte S_t⊆O_t(Nutzer, ...)
        > Menge von Rechten R(r, w, x, send, ...)
        > Zugriffsmatrix M_t = S_t x O_t -> 2^R = Schutz-Zustand zur Zeit t
        > Kommandos für Zustandsübergang(take_right, grant_right, ...)
        > Safety-Problem:
            - geg.: Zugriffsmatrix M_t; Subjekt s ohne Recht r an Objekt o
            - ges.: gibt es Folge von Aufrufen, so dass s das Recht r von o bekommt?
            - kein Algorithmus => Zurückführung auf Halteproblem
        > Vorteile: 
            - einfaches/intuitives Modell; einfache Implementierung(Zugriffskontrolllisten pro Subjekt)
        > Nachteile:
            - Rechtevergabe an Subjekten <=> Subjekt bekommt verschiedene Aufgaben
            - schlechte Skalierung der Subjekte
            - unternehmerische Anforderungen nicht erfüllt
    - Role-based Access-Control
        > Aufgabenorientierte Rechtevergabe durch Rollen(= Aufgabe mit zugehörigen Pflichten & Berechtigungen)
        > RBAC-Modell ∃∧∨∀
            - Menge von Subjekte/Benutzern S; Menge von Rollen R; Menge von Zugriffrechten P 
            - Benutzer-Rollenzuweisung sr: S -> 2^R; Rechte-Rollenzuweisung pr: R -> 2^P
            - Sitzung session: S -> 2^R; R_i∈session(s) => s hat Rolle R_i und ist aktiv in R_i
        > Rollienhierachien: partielle Ordnung ≤ auf R mit R_j ≤ R_i <=> R_i erbt Rechte von R_j
        > Erweitertes Log-in: ∀s∈S: R_i∈session(s) => R_i∈sr(s)
        > Erweitertete Zugriffskontrolle
            - exec: S x P -> Boolean mit exec(s, p) = true <=> s ist berechtigt zu p
            - exec(s, p) = true <=> ∃R_i∈R mit R_i∈session(s) ∧ (p∈pr(R_i) ∨ ∃R_j mit R_i≤R_j: p∈pr(R_j))
        > Constraint RBAC:
            - Statische Aufgabentrennung(Seperation of Duty)
                > SSD⊆RxR mit (R_i, R_j)∈SSD <=> R_i und R_j sind wechselseitig ausgeschlossen
                > Member(R_i) = { s∈S | R_i∈sr(s)  }
                > Beschränkung: ∀R_i, R_j∈R, ∀s∈S: (s∈Member(R_i)∧s∈Member(R_j)) => (R_i, R_j)∉SSD
            - Dynamische Aufgabentrennung
                > DSD⊆RxR mit (R_i, R_j)∈DSD <=> R_i und R_j sind dynamisch w.A
                > Active(s) = { R_i∈R | ∃RL⊆R: session(s)=RL ∧ R_i∈Rl }
                > Beschränkung: ∀R_i, R_j∈R, ∀s∈S: (s∈Member(R_i)∧s∈Member(R_j)∧{R_i, R_j}⊆Active(s)) => (R_i, R_j)∉DSD
        > Vorteile:
            - gute Skalierung der Subjekte(Rollen/Aufgaben eher statisch)
            - unternehmerische Anforderungen erfüllt(seperation of duty) => Große Verbreitung z.B in SAP
        > Nachteile: 
            - Vererbungskonzept verstößt gg need-to-know-Prinzip(= Zugriff auf Informationen, wenn benötigt für Erfüllung einer Aufgabe)
    - Bell-LaPadula-Modell

